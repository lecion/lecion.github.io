
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Android 自定义控件（翻译） | Bubble&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Bubble">
    
    <meta name="description" content="官方文档原文：http://developer.android.com/guide/topics/ui/custom-components.html#compound
全文翻译完">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Bubble&#39;s blog" title="Bubble&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Bubble&#39;s blog">Bubble&#39;s blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/11/06/android-zi-ding-yi-kong-jian-bu-fen-fan-yi/" title="Android 自定义控件（翻译）" itemprop="url">Android 自定义控件（翻译）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="Bubble">Bubble</a>
    </p>
  <p class="article-time">
    <time datetime="2014-11-06T14:24:18.000Z" itemprop="datePublished">2014-11-06</time>
    更新日期:<time datetime="2015-09-12T20:15:43.000Z" itemprop="dateModified">2015-09-13</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义控件"><span class="toc-number">1.</span> <span class="toc-text">自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础的方法"><span class="toc-number">1.1.</span> <span class="toc-text">基础的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整自定义控件"><span class="toc-number">1.2.</span> <span class="toc-text">完整自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承OnDraw()和onMeasure()"><span class="toc-number">1.2.1.</span> <span class="toc-text">继承OnDraw()和onMeasure()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个自定义视图的例子"><span class="toc-number">1.2.2.</span> <span class="toc-text">一个自定义视图的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复合控件"><span class="toc-number">1.3.</span> <span class="toc-text">复合控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复合控件的例子"><span class="toc-number">1.3.1.</span> <span class="toc-text">复合控件的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改存在的视图类型"><span class="toc-number">1.4.</span> <span class="toc-text">修改存在的视图类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1.定义"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2.类初始化"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2.类初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3.复写方法"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">3.复写方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4.使用自定义控件"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">4.使用自定义控件</span></a></li></ol></li></ol></li></ol></li></ol>
		</div>
		
		<p>官方文档原文：<a href="http://developer.android.com/guide/topics/ui/custom-components.html#compound" target="_blank" rel="external">http://developer.android.com/guide/topics/ui/custom-components.html#compound</a></p>
<p>全文翻译完 <a id="more"></a></p>
<h1 id="自定义控件">自定义控件</h1><p>Android提供了许多成熟和强大的控件来构建你的UI，基于最基础的class：View 和 VIewGroup。首先，这个平台包含了许多预构建的View和ViewGroup的子类-依次被称为Widgets和Layouts-你可以用它们来创建你的UI。</p>
<p>可用的widgets的部分列表包括： Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner, 以及拥有更多特性的 AutoCompleteTextView, ImageSwitcher, and TextSwitcher。</p>
<p>可用的Layout有LinearLayout, FrameLayout, RelativeLayout等等。可以查看<a href="http://developer.android.com/guide/topics/ui/layout-objects.html" target="_blank" rel="external">Common Layout Objects</a> 以了解更多信息。</p>
<p>如果你没有找到你需要的widgets或者layouts，你可以创建你自己的View子类。如果你只需要对现有的widgets 或者 layouts进行小的改动，你可以简单的继承现有的widgets 或者 layouts并且复写它们的一些方法。</p>
<p>创建你自己的View子类可以让你清楚地控制它们的外观以及屏幕上每一个元素的功能。为了让你掌握自定义控件的相关知识，这里有一些你可以参考的例子：</p>
<ul>
<li>你可以创建一个完整的自定义显示视图的类型，举个例子，一个“音量控制”的2D视图，类似于模拟的电子控制按钮。</li>
<li>你可以将一些控件组合在一起形成一个独立的控件，可能像下拉选择框（ComboBox），双面板选择器（左面板和右面板各有一个列表，你可以放不同的项目），等等。</li>
<li>你可以改变EditText控件在屏幕上显示的方式（<a href="http://developer.android.com/resources/samples/NotePad/index.html" target="_blank" rel="external">NotePad</a> 是一个很好的例子）。</li>
<li>你可以捕获其他的事件比如press并且用你自己的方式处理他们（比如做一个游戏）。</li>
</ul>
<p>下面的章节将解释怎样去创建自定义视图以及如何在你的应用中使用他们。要获得更详细的说明信息，可以看<a href="http://developer.android.com/reference/android/view/View.html" target="_blank" rel="external">View</a> class</p>
<h2 id="基础的方法">基础的方法</h2><p>这里有一个你所需要怎么开始创建属于你自己的view的概括：</p>
<p>1&#46;继承已经存在的<code>View</code>或者它的其他子类。</p>
<p>2&#46;从它的父类复写一些方法。这些方法以<code>on</code>开头，比如，<code>onDraw()</code>，<code>onMeasure()</code>，以及<code>onKeyDown</code>。这个和<code>Activity</code> 或者 <code>ListAcitivity</code>中的<code>on...</code>回调方法很类似，你经常复写这些关于生命周期函数以及毁掉方法。</p>
<p>3&#46;使用你扩展的class。一旦完成，你扩展的class能够放在view能够使用的任何地方使用。</p>
<blockquote>
<p>​提示：扩展class可以被定义成Activity的内部类，并且使用他们。这非常有用，因为这控制了访问的权限，但这不是必须的（可能你希望能够创建一个公开的View让应用更广泛的使用）。</p>
</blockquote>
<h2 id="完整自定义控件">完整自定义控件</h2><p>完整自定义控件能够用来创建你所希望的任何图形组件。那可能是一个图形化的VU表，那看起来像是一个老式的模拟测量仪器，亦或许是一个”sing-a-long”的歌词视图，会有一个弹性小球跟着歌词移动，因此你可以跟着卡拉ok机歌唱。无论哪种形式，你都想要一些不管怎样组合内置控件都做不到的东西。</p>
<p>幸运的是，你能够轻松的创建出你所需要的控件，唯一的限制可能只是你的想象力、屏幕的尺寸，处理器的性能（记住你的应用最终将运行在比桌面端性能更低的平台上）。</p>
<p>创建完全自定义控件：</p>
<p>1&#46;你可以继承的最普通的控件，毋庸置疑的，是<code>View</code>，所以你将经常以继承<code>View</code>作为创建新控件的开始。</p>
<p>2&#46;你可以提供一个带有attributes以及来自XML的参数的构造器，当然你也可以提供自己的属性（可能是颜色或者UV表的测量范围，或者是指针的宽度和阻尼等等）。</p>
<p>3&#46;你可能想创建你自己的事件监听器，存取和修改属性的方法，以及更多的高级特性。</p>
<p>4&#46;基本上你会复写<code>onMeasure()</code>，如果你想让控件显示一些东西，你也可能会复写<code>onDraw()</code>。它们有其各自的默认行为，<code>onDraw</code>默认不会做任何工作，<code>onMeasure</code>将总是设置尺寸为100*100，这可能不是你所期望的。</p>
<p>5&#46;其他<code>on...</code>方法也将在被需要的时候复写。</p>
<h3 id="继承OnDraw()和onMeasure()">继承<code>OnDraw()</code>和<code>onMeasure()</code></h3><p><code>onDraw()</code>方法传送一个<code>Canvas</code>参数，你能使用它实现任何你希望的东西：2D graphics、其他标准或自定义的组件，各种样式的字体，或者其他你想要的东西。</p>
<blockquote>
<p>Note:这个对3D graphics并不适用。如果你想使用3D graphics，你必须继承<code>SurfaceView</code>而不是<code>View</code>，并且开辟一个单独的线程进行绘制。可以查看 GLSurfaceViewActivity Sample 获得详细信息。 <code>onMeasure()</code>稍微有点复杂。<code>onMeasure()</code>是联系你的组件和它的容器之间的临界部分。<code>onMeasure()</code>应该被复写以高效并准确的测量它包含的部分的尺寸。这显得有些复杂因为它会受限于父布局的约束（通过onMeasure()传递进来的参数)。一旦尺寸定了下来，将通过测量后的宽和高来调用<code>setMeasuredDimension()</code>进行尺寸的设定。如果你复写<code>onMeasure()</code>方法，却没能调用<code>setMeasuredDimension()</code>方法，那么在测量时期，将会产生意外的结果。</p>
</blockquote>
<p>站在更高的层次，实现<code>onMeasure()</code>看起来像这样：</p>
<p>1&#46;复写的<code>onMeasure()</code>方法被调用时，会传入宽和高的测量规格(<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>，两者都是用来表示尺寸的整数代码)，你应该将它们视为对宽高的约束，并在该方法中实现对它们的处理。一个完整的参考可以看<a href="http://developer.android.com/reference/android/view/View.html#onMeasure(int, int" target="_blank" rel="external"><code>View.onMeasure(int, int)</code></a>(这个参考文档很好的解释了整个测量过程)</p>
<p>2&#46;你的组件的<code>onMeasure()</code>方法应该计算出一个能够渲染视图的宽和高。这些尺寸应该保持在传入的规格的范围之内，虽然可以选择超出传入的规格范围（在这种情况下，父布局可以选择如何去处理：包括裁剪、滚动、抛出异常，或者再次尝试调用<code>onMeasure()</code>，可能会传入不同的规格）。</p>
<p>3&#46;一旦宽和高被计算出来，<code>setMeasuredDimension(int width, int height)</code>方法必须被调用，并传入计算出来的结果。如果忽略这一点，结果将会抛出异常。</p>
<p>这里有一个关于其他views的相关方法的总结：</p>
<table><br><thead><br><tr><br>  <th>Category</th><br>  <th>Methods</th><br>  <th>Description</th><br></tr><br></thead><br><tbody><br><tr><br>  <td>Creation</td><br>  <td>Constructors</td><br>  <td>当view通过代码或者通过一个layout文件inflate被创建的时候调用，第二种方式（指inflate）应该解析并且应用一些在layout file中的属性</td><br></tr><br><tr><br>  <td></td><br>  <td>onFinishInflate()</td><br>  <td>在一个view以及它的所有子view从XML被inflate完成之后调用</td><br></tr><br><tr><br>  <td>Layout</td><br>  <td>onMeasure(int, int)</td><br>  <td>决定此view的大小</td><br></tr><br><tr><br>  <td>Layout</td><br>  <td>onLayout(boolean, int, int, int, int)</td><br>  <td>决定此view的位置</td><br></tr><br><tr><br>  <td>Layout</td><br>  <td>onSizeChanged(int, int, int, int)</td><br>  <td>当此view的大小被改变时调用</td><br></tr><br><tr><br>  <td>Drawing</td><br>  <td>onDraw(Canvas);</td><br>  <td>当需要渲染内容时调用</td><br></tr><br><tr><br>  <td>Event Processing</td><br>  <td>onKeyDown(int, KeyEvent)</td><br>  <td>当一个按键落下事件发生时调用</td><br></tr><br><tr><br>  <td>Event Processing</td><br>  <td>onKeyUp(int, KeyEvent)</td><br>  <td>当一个按键抬起事件发生时调用</td><br></tr><br><tr><br>  <td>Event Processing</td><br>  <td>onTrackballEvent(MotionEvent)</td><br>  <td>当一个trackball动作事件发生时调用</td><br></tr><br><tr><br>  <td>Event Processing</td><br>  <td>onTouchEvent(MotionEvent)</td><br>  <td>当一个触摸屏幕事件发生时调用</td><br></tr><br><tr><br>  <td>Focus</td><br>  <td>onFocusChanged(boolean, int, Rect)</td><br>  <td>当焦点改变时调用</td><br></tr><br><tr><br>  <td>Focus</td><br>  <td>onWindowFocusChanged(boolean)</td><br>  <td>当包含此View的窗口被改变时调用</td><br></tr><br><tr><br>  <td>Attaching</td><br>  <td>onAttachedToWindow()</td><br>  <td>当此view和窗口附着时调用</td><br></tr><br><tr><br>  <td>Attaching</td><br>  <td>onDetachedFromWindow()</td><br>  <td>当此view和窗口分离时调用</td><br></tr><br><tr><br>  <td>Attaching</td><br>  <td>onWindowVisibilityChanged(int)</td><br>  <td>当包含此view的窗口可见性被改变时调用</td><br></tr><br></tbody><br></table>

<h3 id="一个自定义视图的例子">一个自定义视图的例子</h3><p>自定义视图的例子在 <a href="http://developer.android.com/resources/samples/ApiDemos/index.html" target="_blank" rel="external">API Demos</a> 中可以查看。这个自定义视图定义在<a href="http://developer.android.com/samples/index.html" target="_blank" rel="external">LabelView</a> 文件中。</p>
<p>LabelView这个例子展现了自定义控件中的许多不同的方面。</p>
<ul>
<li>继承<code>View</code>以完成自定义控件</li>
<li>带参数的构造函数，将用于填充view的参数（在XML中定义的参数）。一些参数会被传入父类的构函数中，但是更重要的是，这里有一些为LabelView自定义的属性。</li>
<li>一些你所希望的public方法，比如<code>setText()</code>， <code>setTextSize()</code> ， <code>setTextColor()</code>……</li>
<li>一个复写的<code>onMeasure</code>方法，用来决定这个控件的大小。(注意在LabelVIew里，真正的工作是在私有方法 <code>measuredWidth()</code>里完成的)</li>
<li>一个复写的<code>onDraw()</code>方法，用来将label绘制到提供的canvas上。</li>
</ul>
<p>​你可以从例子中的<a href="http://developer.android.com/resources/samples/ApiDemos/res/layout/custom_view_1.html" target="_blank" rel="external">custom_view_1.xml</a>看到一些示例用法。特别地，你可以看见<code>android:</code>命名空间的参数和<code>app:</code>命名空间的参数混在一起同时使用。这些<code>app:</code>参数是LabelView能够识别的自定义参数，被定义在R资源定义文件中的内部类 styleable中。（译者注：即R.styleble.<em>*</em>）</p>
<h2 id="复合控件">复合控件</h2><p>如果你不想创建一个完整的自定义控件，而是希望将一些已经存在的控件进行组合复用，那么创建一个复合控件（Compound Controls or Compound Control）将更符合要求。一言蔽之，将一些原子控件或者视图按照逻辑组合在一起就能够形成一个独立的新控件。举个例子，一个下拉列表框(Combo Box)，能够通过一行EditText以及一个带有PopupList的按钮组成。如果你按这个按钮，并且从列表中选择一些东西，它将以选中项填充EditText，但是用户也可以在EditText中直接输入他们喜欢的内容。</p>
<p>在Android中，这里实际上已经有两种其他的Views实现了这样的效果：<a href="http://developer.android.com/reference/android/widget/Spinner.html" target="_blank" rel="external">Spinner</a> 和 <a href="http://developer.android.com/reference/android/widget/AutoCompleteTextView.html" target="_blank" rel="external">AutoCompleteTextView</a>, 但是不管怎样，Combo Box的概念将让我们更容易理解这个复合控件的例子。</p>
<p>创建复合控件： 1. 通常是以一种类型的Layout开始的，所以创建一个class去继承一种Layout。在Combo box这个例子中，我们可能使用水平的<code>LinearLayout</code>。记住其他layouts能够被嵌套在里面，因此，复合控件可以由我们任意混合以及构建。注意，就如同Activity一样，你可以使用XML直接创建包含的控件，或者能够通过代码的方式进行创建。</p>
<ol>
<li><p>在构造方法中，首先获取父类所需要的所有参数，并且在第一行代码就传递到父类的构造函数中。然后你就可以建立其他的视图以便使用你的新控件；这时你可以创建<code>EditText</code>和<code>PopupList</code>。注意你也可能引入你自定义在XML中的的属性和参数，并在构造函数中将这些参数提取出来进行初始化。</p>
</li>
<li><p>你也可以为你包含的视图创建事件监听器，举个例子，当列表的Item被点击时，需要一个监听器在该item被选中时，更新<code>EditText</code>的内容。</p>
</li>
<li><p>你也可能创建你自定义属性的访问方法和修改方法，举个例子，允许<code>EditText</code>的值在创建时被初始化，并且在需要的时候查询它的内容</p>
</li>
<li><p>在继承一个Layout的情况下，你不必复写<code>onDraw()</code>和<code>onMeasure()</code>方法，因为你所继承的layout有很好的默认的处理方法。然后，你仍旧可以复写这些方法，如果你需要的话。</p>
</li>
<li><p>你可能复写其他的 <code>on...</code>方法，比如 <code>onKeyDown()</code>，可能是为了当combo box的列表中有一个确定的键被点击时，能够有默认的值被选中。</p>
</li>
</ol>
<p>总而言之，使用现有的Layout区创建自定义控件有许多好处，包括：</p>
<ul>
<li>你可以像Activity一样通过使用XML来指定layout的样式，或者你可以通过硬编码的方式将已有控件嵌套到你的layout中。</li>
<li><code>onDraw()</code>和<code>onMeasure</code>方法（和更多其他的<code>on...</code>方法）不需要进行复写，默认的情况下已经足够使用。</li>
<li>最后，你可以快速创建复合控件，并且重复使用他们因为他们就像他们是一个独立的控件一样。</li>
</ul>
<h3 id="复合控件的例子">复合控件的例子</h3><p>在SDK自带的 API Demos 项目中，这里有两个List例子-Example 4 和 Example 6，位于 <code>Views/Lists</code>中：继承自LinearLayout的<code>SpeechView</code>能够显示Speech quotes。在例子中对应的class文件是<code>List4.java</code>和<code>List6.java</code>。</p>
<h2 id="修改存在的视图类型">修改存在的视图类型</h2><p>在某些情况下，这里甚至有更简单的方式去创建自定义控件。如果这里有一个和你想要的控件非常类似的控件，你可以简单的继承它并且复写你想改变的一些行为。你可以通过完全自定义控件的方式去实现这些东西，但是通过继承现有的View区改变一些属性，你也可以得到许多你希望要的行为并且改变它们。</p>
<p>举个例子，SDK 的samples里包含了<a href="http://developer.android.com/resources/samples/NotePad/index.html" target="_blank" rel="external">Notepad application</a> 。它展现了使用Android平台现有的EditText去创建一个有纹理的笔记本的许多可以参考的方面。这不是一个完美的例子，而且APIs为了完成这些也许会改变它之前的样子，但是它展现了自定义控件的原则。</p>
<p>如果你还没有做过这些，导入 Notepad 示例到Eclipse（或者只是查看源码）。尤其注意查看<code>NoteEditor.java</code>中定义的<code>MyEditText</code>。</p>
<p>一些注意的点列在这里</p>
<h4 id="1&#46;定义">1&#46;定义</h4><p>这个class使用如下行代码被定义 <code>public static class MyEditText extends EditText</code> <em> 它被定义为<code>NoteEditor</code> Activity的一个内部类，但是它是公开的，所以它能够以<code>NoteEditor.MyEditText</code>的形式被外部访问。 </em> 它是static的，意味着它不需要生成所谓的”合成方法”，允许它从父类访问数据的方法。相应地也意味着它表现得像一个完全独立的class而不依赖于NoteEditor。这是一个cleanr的方式去创建内部类，如果不需要访问外部类的状态的话。保持生成的class简单，并且让其他class也能轻松使用。 * 它集成自EditText，被我们选择用来自定义控件。当我们完成时，这个新的class将能够兼容普通的<code>EditText</code>。</p>
<h4 id="2&#46;类初始化">2&#46;类初始化</h4><p>通常，父类构造函数将被首先调用。此外，这不是一个默认的构造函数，而是一个带有参数的构造函数。EditText 伴随着从XML文件里填充的参数被创建，因此，我们的构造函数也需要获得这些参数并且传递到父类构造函数中。</p>
<h4 id="3&#46;复写方法">3&#46;复写方法</h4><p>在这个例子中，只有一个方法被复写：<code>onDraw()</code>-但是当你创建自定义控件时，可以轻松的复写其他需要的方法。</p>
<p>对于Notepad 这个例子，复写<code>onDraw()</code>允许我们在EditText的canvas（canvas是传递到onDraw()方法中的）中绘制蓝色的线条。<code>super.onDraw()</code>方法在该方法结束前被调用。父类方法应该被调用，但是在这种情况下，我们在绘制完我们想要包含的线条之后才调用。</p>
<h4 id="4&#46;使用自定义控件">4&#46;使用自定义控件</h4><p>我们现在拥有了自定义的控件，但是该怎么使用呢？在Notepad例子中，自定义控件被直接使用，因此，让我们看看在<code>res/layout</code>文件夹中的<code>note_editor.xml</code></p>
<pre><code>&amp;<span class="keyword">lt</span>;view
  class=<span class="string">"com.android.notepad.NoteEditor<span class="variable">$MyEditText</span>"</span> 
  id=<span class="string">"<span class="variable">@+</span>id/note"</span>
  android:layout_width=<span class="string">"fill_parent"</span>
  android:layout_height=<span class="string">"fill_parent"</span>
  android:background=<span class="string">"<span class="variable">@android</span>:drawable/empty"</span>
  android:padding=<span class="string">"10dip"</span>
  android:scrollbars=<span class="string">"vertical"</span>
  android:fadingEdge=<span class="string">"vertical"</span> /&amp;<span class="keyword">gt</span>;
</code></pre><ul>
<li>自定义控件从XML文件中被创建，并且以完整的包名进行指定。注意也使用了java编程语言中调用内部类的方式<code>NoteEditor$MyEditText</code>来使用内部类。 如果你的自定义控件没有被定义成内部类，那么你可以通过XMl的名字来声明视图，并且排除class属性。举个例子：</li>
</ul>
<p>&lt;com.android.notepad.MyEditText id=”@+id/note” … /&gt;</p>
<p>注意MyEditText类现在是一个独立的class文件。当这个class被嵌入NoteEditor时，这样的方式将不会生效。</p>
<ul>
<li>定义的其他属性和参数将被传入自定义控件的构造函数，然后传入EditText的构造函数，所以你可以使用EditText一样的属性来指定你自定义控件的属性。注意你也可以自己添加参数，我们将在后面讨论这个内容。</li>
</ul>
<p>这就是全部的内容。诚然这是一个简单的例子，但是关键是-创建自定义布局是取决于你自己的需求。</p>
<p>一个更成熟的自定义控件也许会复写更多的<code>on...</code>和它们的一些帮助方法，本质也是一样的自定义它们的属性和行为。唯一的限制是你的想象力以及你需要控件做什么。</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2014/11/06/android-zi-ding-yi-kong-jian-bu-fen-fan-yi/" data-title="Android 自定义控件（翻译） | Bubble&#39;s blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/12/26/jmm-zhi-volatile/" title="JMM之Volatile">
  <strong>PREVIOUS:</strong><br/>
  <span>
  JMM之Volatile</span>
</a>
</div>


<div class="next">
<a href="/2014/10/31/xin-ji-neng-jie-shui-jing-tou/"  title="新技能get√——接水晶头">
 <strong>NEXT:</strong><br/> 
 <span>新技能get√——接水晶头
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义控件"><span class="toc-number">1.</span> <span class="toc-text">自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础的方法"><span class="toc-number">1.1.</span> <span class="toc-text">基础的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整自定义控件"><span class="toc-number">1.2.</span> <span class="toc-text">完整自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承OnDraw()和onMeasure()"><span class="toc-number">1.2.1.</span> <span class="toc-text">继承OnDraw()和onMeasure()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个自定义视图的例子"><span class="toc-number">1.2.2.</span> <span class="toc-text">一个自定义视图的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复合控件"><span class="toc-number">1.3.</span> <span class="toc-text">复合控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复合控件的例子"><span class="toc-number">1.3.1.</span> <span class="toc-text">复合控件的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改存在的视图类型"><span class="toc-number">1.4.</span> <span class="toc-text">修改存在的视图类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1.定义"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2.类初始化"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2.类初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3.复写方法"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">3.复写方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4.使用自定义控件"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">4.使用自定义控件</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
			<li><a href="/categories/Android/" title="Android">Android<sup>3</sup></a></li>
		
			<li><a href="/categories/Java/" title="Java">Java<sup>1</sup></a></li>
		
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		
			<li><a href="/categories/服务器/" title="服务器">服务器<sup>1</sup></a></li>
		
			<li><a href="/categories/未分类/" title="未分类">未分类<sup>2</sup></a></li>
		
			<li><a href="/categories/生活/" title="生活">生活<sup>1</sup></a></li>
		
		</ul>
</div>


  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="Bubble">Bubble</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
